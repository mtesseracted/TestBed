# Trap DEBUG to exec before commands, only in newer bash
# this is unsupported in bash3, DEBUG trap execs after
# https://superuser.com/questions/175799/does-bash-have-a-hook-that-is-run-before-executing-a-command
#newer on github: https://github.com/rcaloras/bash-preexec
X1_PRECNT=0         #command counter to know if cmd was blank (no increment)
X1_CMDCNT=0
X1_PRETIM=$SECONDS  #time tracker
X1_DELAY='3'       #Min cmd time to print
# X1_TIMING='false' #do a check first of bash version and notify-send
# installed
preexec_invoke() {
    [ -n "$COMP_LINE" ] && return                     #ignore auto-complete
    [ "$BASH_COMMAND" = "$PROMPT_COMMAND" ] && return #ignore PS1 func
    X1_PRECMD=$BASH_COMMAND  #store command
    ((X1_PRECNT++))          #increment counter, to know empty prompt
    X1_PRETIM=$SECONDS       #store time of command
    echo -e "\e]0;"; echo -n $BASH_COMMAND; echo -ne "\007" #set win title
}
trap 'preexec_invoke' DEBUG #trap DEBUG execs before every 'simple' command

x1alert(){
    case "$1" in "vi"*) ;;
	*)
	    #--hint=int:transient:1 # add and then isn't persistent
	    # can maybe make 2 versions, really long ones will persist?
	    notify-send --urgency=low \
	                -i "$([ $? = 0 ] && echo terminal || echo error)" \
			 "$1 took $2"
	;;
    esac
}

# PS1 setting function, features:
# print in color if available
# first print user@host:time/cmd time
#   highlight host color if SSH session
# print abbreviated path that dynamically
#   abbreviates the dir names to be shorter
#   the longer the total path is
# print the last exit status at the end    

#  UPDATE: print last cmd time if >X1_DELAY
##  This may overwrite defined history settings!!
##  Untested in tmux

tput colors &>/dev/null #check for colors first
if [ $? -eq 0 ]; then
    X1_SCOLG='\[\e[1;32m\]' #green
    X1_SCOLG0='\[\e[0;32m\]' #green unbold
    X1_SCOLY='\[\e[0;33m\]' #yellow
    X1_SCOLC='\[\e[1;36m\]' #cyan
    X1_SCOLB='\[\e[1;34m\]' #blue
    X1_SCOLR='\[\e[1;31m\]' #red
    X1_ECOL='\[\e[00m\]' #end colors
else
    X1_SCOLG=''
    X1_SCOLG0=''
    X1_SCOLC=''
    X1_SCOLB=''
    X1_SCOLR=''
    X1_ECOL=''
fi

 
X1FormTime(){ #Convert sec to [hr]+min+sec for display
    #This can be called w/o subshell if use printf -v
    local hr=$(( $1/3600 ))
    local min=$(( ($1/60) - ($hr*3600) ))
    local sec=$(( $1 - ($min*60) ))

    if [ "$hr" != "0" ]; then                              #hr > 0, red
	printf -v X1_CMDTIME "%dh%02dm%02ds" $hr $min $sec
	x1alert "$X1_PRECMD" "$X1_CMDTIME"
	printf -v X1_CMDTIME "${X1_SCOLR}$X1_CMDTIME$X1_ECOL"
    elif [ "$min" != "0" ]; then                           #mins > 0, yellow
	printf -v X1_CMDTIME "%dm%02ds" $min $sec
	x1alert "$X1_PRECMD" "$X1_CMDTIME"
	printf -v X1_CMDTIME "${X1_SCOLY}$X1_CMDTIME$X1_ECOL"
    else                                                   #mins = 0, green
	printf -v X1_CMDTIME "0m%02ds" $sec
	x1alert "$X1_PRECMD" "$X1_CMDTIME"
	printf -v X1_CMDTIME "${X1_SCOLG0}$X1_CMDTIME$X1_ECOL"
    fi
}

get_PS1() {
# Idea for git branch inclusion: replace user@host if we're on a git
#   branch, or maybe just user since host tells us if we're ssh'ing
#   or maybe dynamicly can replace host if git branch is really long
#   can also omit time if not delayed

    local stat="$?"        # get last exits status
    if [ $stat = 0 ]; then # set exit status color
        stat=""
    else
	stat="${X1_SCOLR}${stat}${X1_ECOL}"
    fi

    local x1time="$X1_SCOLG0\A$X1_ECOL" #Displayed time, default green clock
    if [ -z "$X1_TMING" ]; then
        if [ $(($SECONDS - $X1_PRETIM)) -gt $X1_DELAY ] && \
           [ "$X1_PRECNT" != "$X1_CMDCNT" ]; then

	    X1FormTime $(($SECONDS -$X1_PRETIM))
	    x1time=$X1_CMDTIME
            X1_CMDCNT=$X1_PRECNT
    fi; fi

    #get the pwd split into dirs
    local IFS="/"
    local PARTS=()
    read -ra PARTS <<< "$PWD" 
    local plast="${#PARTS[@]}"
    plast=$(($plast-1))

    #get the home dir and check if the
    #beginning of pwd matches
    local HPATH=()
    read -ra HPATH <<< "$HOME"

    local j=0; local same=0
    if [ "${#HPATH[@]}" -gt 0 ]; then
	for i in "${HPATH[@]}"; do
	    if [ "$i" != "${PARTS[$j]}" ]; then 
		same=1
	    fi
	    j=$(($j + 1))
	done
    else
	same=1
    fi
    if [ $same = 0 ]; then
	#if we are in a sub-dir of $HOME
	#then shorten to cut off from pwd
	unset "HPATH[${#HPATH[@]}-1]"
	j=1
	for i in "${HPATH[@]}"; do
	    #this shrinks parts but leaves the
	    #first element which is a space
	    unset "PARTS[$j]"
	    j=$(($j+1))
	done
    fi

    #Now get the current dir and shrink pwd
    if [ ${#PARTS[@]} -gt 1 ]; then
	#local cdir="${PARTS[-1]}"
	local cdir="${PARTS[$plast]}"
	unset "PARTS[$plast]"
    else
	#we're in the home or root dir
	local cdir=""
	PARTS=""
    fi

    #set how much to abbreviate dir names
    local lenmax=3
    local plen=$(($lenmax*$plast +${#cdir}))
    if [ $plen -gt 24 ]; then
	lenmax=$(($lenmax -1))
	plen=$(($lenmax*$plast +${#cdir}))
	if [ $plen -gt 30 ]; then
	    lenmax=$(($lenmax -1))
            if [ "${#cdir}" -gt 10 ]; then
                cdir="${cdir::3}[~]${cdir:$((${#cdir}-5))}"
                #cdir="${cdir::3}$X1_ECOL[~]$X1_SCOLB${cdir:$((${#cdir}-5))}"
    fi; fi; fi

    #now set the directory to display in PS1
    local dispdir=""
    for i in "${PARTS[@]}"; do
	if [ "$i" == "" ]; then
	    #PARTS[0] == "" from read
	    if [ $same = 0 ]; then
		#we're in a sub-dir of HOME
		i="~"
		dispdir="${dispdir}$i"
	    fi
	else
	    if [ "${#i}" -gt $lenmax ]; then
		i=${i::$lenmax}
	    fi
	    dispdir="${dispdir}/$i"
	fi
    done
    #append the cdir if we aren't in HOME
    if [ "$cdir" != "" ]; then
	dispdir="$dispdir/$cdir"
    fi

    #check if we're in an ssh session
    if [ -n "$SSH_CLIENT" ]; then
	local host="$X1_SCOLG\h$X1_ECOL" #bold
    else
	local host="$X1_SCOLG0\h$X1_ECOL"
    fi

    local gsep="$X1_SCOLG0|$X1_ECOL" #green vert
    local user="$X1_SCOLG0\u@$X1_ECOL" #green user
    local dispdir="$X1_SCOLB$dispdir$X1_ECOL" #blue pwd
    PS1="$user$host$gsep$x1time$gsep$dispdir\$$stat> "
    #echo "$user$host$gsep$time$gsep$dispdir\$$stat> "
}
PROMPT_COMMAND=get_PS1

